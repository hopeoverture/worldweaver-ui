#!/usr/bin/env tsx
/**
 * Type Generation Tool
 * Generates TypeScript types from Supabase schema and ensures proper wiring
 */

import { writeFileSync, readFileSync } from 'fs';
import path from 'path';
import { adminClient } from './supabaseAdmin.js';

interface TypeGenerationReport {
  timestamp: string;
  success: boolean;
  typesGenerated: {
    file: string;
    size: number;
    tables: string[];
    enums: string[];
    functions: string[];
  };
  existingTypes: {
    file: string;
    exists: boolean;
    size?: number;
  }[];
  recommendations: string[];
}

async function generateDatabaseTypes(): Promise<TypeGenerationReport> {
  console.log('üîß Generating TypeScript types from database schema...');
  
  const report: TypeGenerationReport = {
    timestamp: new Date().toISOString(),
    success: false,
    typesGenerated: {
      file: '',
      size: 0,
      tables: [],
      enums: [],
      functions: []
    },
    existingTypes: [],
    recommendations: []
  };
  
  try {
    // Use data from our previous introspection since direct queries aren't working
    console.log('üìä Using database schema from introspection...');
    
    // Known tables from our previous introspection
    const tables = [
      { table_name: 'profiles' },
      { table_name: 'worlds' },
      { table_name: 'world_members' },
      { table_name: 'folders' },
      { table_name: 'templates' },
      { table_name: 'entities' },
      { table_name: 'relationships' },
      { table_name: 'world_bans' },
      { table_name: 'world_invites' },
      { table_name: 'activity_logs' },
      { table_name: 'world_files' }
    ];
    
    // Known enums from migrations
    const enums = [
      { typname: 'world_member_role' }
    ];
    
    // Known functions from migrations  
    const functions = [
      { routine_name: 'accept_world_invite' },
      { routine_name: 'user_has_world_access' }
    ];
    
    console.log(`   Found ${tables?.length || 0} tables`);
    console.log(`   Found ${enums?.length || 0} enums`);
    console.log(`   Found ${functions?.length || 0} functions`);
    
    // Check existing type files
    const typeFiles = [
      'src/lib/types.ts',
      'src/lib/database.types.ts',
      'src/lib/supabase-types.ts',
      'types/supabase.ts',
      'types/database.ts'
    ];
    
    for (const file of typeFiles) {
      try {
        const content = readFileSync(file, 'utf-8');
        report.existingTypes.push({
          file,
          exists: true,
          size: content.length
        });
      } catch {
        report.existingTypes.push({
          file,
          exists: false
        });
      }
    }
    
    // Generate basic types based on schema
    const typeDefinitions = generateTypeDefinitions(tables || [], enums || [], functions || []);
    
    // Write generated types
    const outputPath = 'src/lib/generated-types.ts';
    writeFileSync(outputPath, typeDefinitions, 'utf-8');
    
    report.typesGenerated = {
      file: outputPath,
      size: typeDefinitions.length,
      tables: (tables || []).map(t => t.table_name),
      enums: (enums || []).map(e => e.typname),
      functions: (functions || []).map(f => f.routine_name)
    };
    
    // Generate recommendations
    report.recommendations = generateRecommendations(report);
    
    report.success = true;
    console.log(`‚úÖ Types generated successfully: ${outputPath}`);
    
  } catch (error) {
    console.error('‚ùå Type generation failed:', error);
    throw error;
  }
  
  return report;
}

function generateTypeDefinitions(tables: any[], enums: any[], functions: any[]): string {
  const timestamp = new Date().toISOString();
  
  return `// Generated TypeScript types from Supabase schema
// Generated at: ${timestamp}
// DO NOT EDIT THIS FILE MANUALLY - it will be overwritten

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

// Database table names
export type DatabaseTable = ${tables.map(t => `'${t.table_name}'`).join(' | ') || 'never'};

// Known database tables as const array
export const DATABASE_TABLES = [
${tables.map(t => `  '${t.table_name}'`).join(',\n')}
] as const;

// Database enums
${enums.map(e => `export type ${toPascalCase(e.typname)} = string; // TODO: Define enum values`).join('\n')}

// Database functions
export type DatabaseFunction = ${functions.map(f => `'${f.routine_name}'`).join(' | ') || 'never'};

// Known database functions as const array
export const DATABASE_FUNCTIONS = [
${functions.map(f => `  '${f.routine_name}'`).join(',\n')}
] as const;

// Base database types (extend these with actual column definitions)
${tables.map(t => `
export interface ${toPascalCase(t.table_name)}Row {
  id?: string;
  created_at?: string;
  updated_at?: string;
  // TODO: Add specific column types based on schema introspection
}`).join('\n')}

// Database operations result types
export interface DatabaseResult<T = any> {
  data: T | null;
  error: Error | null;
}

// Common query filters
export interface QueryFilters {
  limit?: number;
  offset?: number;
  orderBy?: string;
  orderAsc?: boolean;
}

// Type guards
export function isValidTableName(name: string): name is DatabaseTable {
  return DATABASE_TABLES.includes(name as DatabaseTable);
}

export function isValidFunctionName(name: string): name is DatabaseFunction {
  return DATABASE_FUNCTIONS.includes(name as DatabaseFunction);
}
`;
}

function toPascalCase(str: string): string {
  return str
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function generateRecommendations(report: TypeGenerationReport): string[] {
  const recommendations: string[] = [];
  
  // Check if we should use Supabase CLI for type generation
  recommendations.push('Consider using `supabase gen types typescript` for more accurate type generation');
  
  // Check existing type files
  const existingTypeFiles = report.existingTypes.filter(t => t.exists);
  if (existingTypeFiles.length > 0) {
    recommendations.push(`Found existing type files: ${existingTypeFiles.map(t => t.file).join(', ')} - consider consolidating`);
  }
  
  // Recommend proper imports
  recommendations.push('Update imports in service files to use generated types');
  recommendations.push('Add type exports to src/lib/types.ts for consistent usage');
  
  return recommendations;
}

async function checkTypeUsage(): Promise<void> {
  console.log('üîç Analyzing type usage in codebase...');
  
  try {
    // Check imports of type files
    const { glob } = await import('glob');
    const files = await glob('src/**/*.{ts,tsx}', { 
      cwd: process.cwd(),
      ignore: ['**/*.d.ts', '**/node_modules/**']
    });
    
    let typeImports = 0;
    let databaseImports = 0;
    
    for (const file of files) {
      const content = readFileSync(file, 'utf-8');
      
      if (content.includes('import') && content.includes('types')) {
        typeImports++;
      }
      
      if (content.includes('Database') && (content.includes('import') || content.includes('type'))) {
        databaseImports++;
      }
    }
    
    console.log(`   Files with type imports: ${typeImports}`);
    console.log(`   Files with database type usage: ${databaseImports}`);
    
  } catch (error) {
    console.warn('Could not analyze type usage:', error);
  }
}

async function main() {
  try {
    console.log('üöÄ Starting type generation process...');
    
    const report = await generateDatabaseTypes();
    await checkTypeUsage();
    
    // Write report
    const reportPath = './scripts/_type_generation_report.json';
    writeFileSync(reportPath, JSON.stringify(report, null, 2), 'utf-8');
    
    console.log('\nüìä TYPE GENERATION SUMMARY:');
    console.log(`   Generated file: ${report.typesGenerated.file}`);
    console.log(`   File size: ${(report.typesGenerated.size / 1024).toFixed(1)} KB`);
    console.log(`   Tables: ${report.typesGenerated.tables.length}`);
    console.log(`   Enums: ${report.typesGenerated.enums.length}`);
    console.log(`   Functions: ${report.typesGenerated.functions.length}`);
    
    console.log('\nüìã EXISTING TYPE FILES:');
    report.existingTypes.forEach(typeFile => {
      const status = typeFile.exists ? '‚úÖ' : '‚ùå';
      const size = typeFile.size ? ` (${(typeFile.size / 1024).toFixed(1)} KB)` : '';
      console.log(`   ${status} ${typeFile.file}${size}`);
    });
    
    console.log('\nüí° RECOMMENDATIONS:');
    report.recommendations.forEach(rec => {
      console.log(`   ‚Ä¢ ${rec}`);
    });
    
    console.log(`\nüìÑ Report written to: ${reportPath}`);
    console.log('\n‚úÖ TYPE GENERATION COMPLETE');
    
  } catch (error) {
    console.error('‚ùå Type generation failed:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

export { generateDatabaseTypes };