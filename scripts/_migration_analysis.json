{
  "migrationFiles": [
    {
      "filename": "20250906000001_create_tables.sql",
      "timestamp": "20250906000001",
      "name": "create tables",
      "path": "supabase\\migrations\\20250906000001_create_tables.sql",
      "content": "-- WorldWeaver Database Schema\r\n-- Core tables for the WorldWeaver application\r\n\r\n-- Enable UUID extension\r\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\r\n\r\n-- =====================================================\r\n-- USERS & AUTHENTICATION\r\n-- =====================================================\r\n-- Note: Supabase automatically creates auth.users table\r\n-- We'll create a profiles table to extend user data\r\n\r\nCREATE TABLE public.profiles (\r\n    id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,\r\n    email TEXT UNIQUE NOT NULL,\r\n    full_name TEXT,\r\n    avatar_url TEXT,\r\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\r\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\r\n);\r\n\r\n-- =====================================================\r\n-- WORLDS - Core container for all content\r\n-- =====================================================\r\n\r\nCREATE TABLE public.worlds (\r\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\r\n    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\r\n    name TEXT NOT NULL,\r\n    description TEXT,\r\n    is_public BOOLEAN DEFAULT FALSE,\r\n    is_archived BOOLEAN DEFAULT FALSE,\r\n    settings JSONB DEFAULT '{}',\r\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\r\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\r\n);\r\n\r\n-- =====================================================\r\n-- WORLD MEMBERS - User access to worlds\r\n-- =====================================================\r\n\r\nCREATE TYPE world_member_role AS ENUM ('viewer', 'editor', 'admin');\r\n\r\nCREATE TABLE public.world_members (\r\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\r\n    world_id UUID REFERENCES public.worlds(id) ON DELETE CASCADE NOT NULL,\r\n    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\r\n    role world_member_role DEFAULT 'viewer',\r\n    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\r\n    UNIQUE(world_id, user_id)\r\n);\r\n\r\n-- =====================================================\r\n-- FOLDERS - Organization structure within worlds\r\n-- =====================================================\r\n\r\nCREATE TABLE public.folders (\r\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\r\n    world_id UUID REFERENCES public.worlds(id) ON DELETE CASCADE NOT NULL,\r\n    parent_folder_id UUID REFERENCES public.folders(id) ON DELETE CASCADE,\r\n    name TEXT NOT NULL,\r\n    description TEXT,\r\n    color TEXT DEFAULT '#6B7280',\r\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\r\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\r\n);\r\n\r\n-- =====================================================\r\n-- TEMPLATES - Entity type definitions\r\n-- =====================================================\r\n\r\nCREATE TABLE public.templates (\r\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\r\n    world_id UUID REFERENCES public.worlds(id) ON DELETE CASCADE,\r\n    name TEXT NOT NULL,\r\n    description TEXT,\r\n    icon TEXT DEFAULT 'file-text',\r\n    category TEXT DEFAULT 'general',\r\n    fields JSONB NOT NULL DEFAULT '[]',\r\n    is_system BOOLEAN DEFAULT FALSE,\r\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\r\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\r\n);\r\n\r\n-- =====================================================\r\n-- ENTITIES - The actual content instances\r\n-- =====================================================\r\n\r\nCREATE TABLE public.entities (\r\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\r\n    world_id UUID REFERENCES public.worlds(id) ON DELETE CASCADE NOT NULL,\r\n    template_id UUID REFERENCES public.templates(id) ON DELETE SET NULL,\r\n    folder_id UUID REFERENCES public.folders(id) ON DELETE SET NULL,\r\n    name TEXT NOT NULL,\r\n    data JSONB NOT NULL DEFAULT '{}',\r\n    tags TEXT[] DEFAULT ARRAY[]::TEXT[],\r\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\r\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL\r\n);\r\n\r\n-- =====================================================\r\n-- RELATIONSHIPS - Connections between entities\r\n-- =====================================================\r\n\r\nCREATE TABLE public.relationships (\r\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\r\n    world_id UUID REFERENCES public.worlds(id) ON DELETE CASCADE NOT NULL,\r\n    from_entity_id UUID REFERENCES public.entities(id) ON DELETE CASCADE NOT NULL,\r\n    to_entity_id UUID REFERENCES public.entities(id) ON DELETE CASCADE NOT NULL,\r\n    relationship_type TEXT NOT NULL DEFAULT 'related',\r\n    description TEXT,\r\n    metadata JSONB DEFAULT '{}',\r\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\r\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\r\n    CHECK (from_entity_id != to_entity_id)\r\n);\r\n\r\n-- =====================================================\r\n-- WORLD BANS - User moderation\r\n-- =====================================================\r\n\r\nCREATE TABLE public.world_bans (\r\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\r\n    world_id UUID REFERENCES public.worlds(id) ON DELETE CASCADE NOT NULL,\r\n    banned_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\r\n    banned_by_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\r\n    reason TEXT,\r\n    banned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\r\n    UNIQUE(world_id, banned_user_id)\r\n);\r\n\r\n-- =====================================================\r\n-- INDEXES for performance\r\n-- =====================================================\r\n\r\nCREATE INDEX idx_worlds_owner_id ON public.worlds(owner_id);\r\nCREATE INDEX idx_world_members_world_id ON public.world_members(world_id);\r\nCREATE INDEX idx_world_members_user_id ON public.world_members(user_id);\r\nCREATE INDEX idx_folders_world_id ON public.folders(world_id);\r\nCREATE INDEX idx_templates_world_id ON public.templates(world_id);\r\nCREATE INDEX idx_entities_world_id ON public.entities(world_id);\r\nCREATE INDEX idx_relationships_world_id ON public.relationships(world_id);\r\n\r\n-- =====================================================\r\n-- FUNCTIONS AND TRIGGERS\r\n-- =====================================================\r\n\r\n-- Function to update updated_at timestamp\r\nCREATE OR REPLACE FUNCTION update_updated_at_column()\r\nRETURNS TRIGGER AS $$\r\nBEGIN\r\n    NEW.updated_at = NOW();\r\n    RETURN NEW;\r\nEND;\r\n$$ language 'plpgsql';\r\n\r\n-- Apply updated_at trigger to relevant tables\r\nCREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\r\nCREATE TRIGGER update_worlds_updated_at BEFORE UPDATE ON public.worlds FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\r\nCREATE TRIGGER update_folders_updated_at BEFORE UPDATE ON public.folders FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\r\nCREATE TRIGGER update_templates_updated_at BEFORE UPDATE ON public.templates FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\r\nCREATE TRIGGER update_entities_updated_at BEFORE UPDATE ON public.entities FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\r\n\r\n-- Function to automatically create profile when user signs up\r\nCREATE OR REPLACE FUNCTION public.handle_new_user()\r\nRETURNS TRIGGER AS $$\r\nBEGIN\r\n    INSERT INTO public.profiles (id, email, full_name, avatar_url)\r\n    VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'avatar_url');\r\n    RETURN NEW;\r\nEND;\r\n$$ LANGUAGE plpgsql SECURITY DEFINER;\r\n\r\n-- Trigger to call the function every time a user is created\r\nCREATE TRIGGER on_auth_user_created\r\n    AFTER INSERT ON auth.users\r\n    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();\r\n\r\n-- Function to auto-add world owner as admin member\r\nCREATE OR REPLACE FUNCTION public.add_owner_as_member()\r\nRETURNS TRIGGER AS $$\r\nBEGIN\r\n    INSERT INTO public.world_members (world_id, user_id, role)\r\n    VALUES (NEW.id, NEW.owner_id, 'admin');\r\n    RETURN NEW;\r\nEND;\r\n$$ LANGUAGE plpgsql SECURITY DEFINER;\r\n\r\n-- Trigger to automatically add world owner as admin member\r\nCREATE TRIGGER on_world_created\r\n    AFTER INSERT ON public.worlds\r\n    FOR EACH ROW EXECUTE FUNCTION public.add_owner_as_member();\r\n\r\n-- =====================================================\r\n-- SYSTEM TEMPLATES\r\n-- =====================================================\r\n\r\n-- Insert system templates that are available across all worlds\r\nINSERT INTO public.templates (id, world_id, name, description, icon, category, fields, is_system) VALUES\r\n    (\r\n        '550e8400-e29b-41d4-a716-446655440001'::UUID,\r\n        NULL,\r\n        'Character',\r\n        'A person, creature, or being in your world',\r\n        'user',\r\n        'people',\r\n        '[\r\n            {\"name\": \"appearance\", \"type\": \"textarea\", \"label\": \"Appearance\", \"required\": false},\r\n            {\"name\": \"personality\", \"type\": \"textarea\", \"label\": \"Personality\", \"required\": false},\r\n            {\"name\": \"background\", \"type\": \"textarea\", \"label\": \"Background\", \"required\": false},\r\n            {\"name\": \"goals\", \"type\": \"textarea\", \"label\": \"Goals & Motivations\", \"required\": false},\r\n            {\"name\": \"relationships\", \"type\": \"textarea\", \"label\": \"Relationships\", \"required\": false}\r\n        ]'::JSONB,\r\n        TRUE\r\n    ),\r\n    (\r\n        '550e8400-e29b-41d4-a716-446655440002'::UUID,\r\n        NULL,\r\n        'Location',\r\n        'A place, building, or geographical feature',\r\n        'map-pin',\r\n        'places',\r\n        '[\r\n            {\"name\": \"description\", \"type\": \"textarea\", \"label\": \"Description\", \"required\": false},\r\n            {\"name\": \"geography\", \"type\": \"textarea\", \"label\": \"Geography\", \"required\": false},\r\n            {\"name\": \"climate\", \"type\": \"text\", \"label\": \"Climate\", \"required\": false},\r\n            {\"name\": \"population\", \"type\": \"text\", \"label\": \"Population\", \"required\": false},\r\n            {\"name\": \"government\", \"type\": \"text\", \"label\": \"Government\", \"required\": false},\r\n            {\"name\": \"notable_features\", \"type\": \"textarea\", \"label\": \"Notable Features\", \"required\": false}\r\n        ]'::JSONB,\r\n        TRUE\r\n    );\r\n",
      "size": 10013
    },
    {
      "filename": "20250906000002_create_policies.sql",
      "timestamp": "20250906000002",
      "name": "create policies",
      "path": "supabase\\migrations\\20250906000002_create_policies.sql",
      "content": "-- WorldWeaver Database Schema - RLS Policies\r\n-- Row Level Security policies for multi-tenant access control\r\n\r\n-- Enable RLS on all tables\r\nALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE public.worlds ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE public.world_members ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE public.folders ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE public.entities ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE public.relationships ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE public.world_bans ENABLE ROW LEVEL SECURITY;\r\n\r\n-- =====================================================\r\n-- PROFILE POLICIES\r\n-- =====================================================\r\n\r\nCREATE POLICY \"Users can view their own profile\"\r\n    ON public.profiles FOR SELECT\r\n    USING (auth.uid() = id);\r\n\r\nCREATE POLICY \"Users can update their own profile\"\r\n    ON public.profiles FOR UPDATE\r\n    USING (auth.uid() = id);\r\n\r\n-- =====================================================\r\n-- HELPER FUNCTION TO CHECK WORLD ACCESS\r\n-- =====================================================\r\n\r\n-- Create a function to check if user has access to a world\r\nCREATE OR REPLACE FUNCTION user_has_world_access(world_uuid UUID, user_uuid UUID)\r\nRETURNS BOOLEAN AS $$\r\nBEGIN\r\n  -- Check if user is owner\r\n  IF EXISTS (\r\n    SELECT 1 FROM public.worlds \r\n    WHERE id = world_uuid AND owner_id = user_uuid\r\n  ) THEN\r\n    RETURN TRUE;\r\n  END IF;\r\n  \r\n  -- Check if world is public\r\n  IF EXISTS (\r\n    SELECT 1 FROM public.worlds \r\n    WHERE id = world_uuid AND is_public = TRUE\r\n  ) THEN\r\n    RETURN TRUE;\r\n  END IF;\r\n  \r\n  -- Check if user is a member\r\n  IF EXISTS (\r\n    SELECT 1 FROM public.world_members \r\n    WHERE world_id = world_uuid AND user_id = user_uuid\r\n  ) THEN\r\n    RETURN TRUE;\r\n  END IF;\r\n  \r\n  RETURN FALSE;\r\nEND;\r\n$$ LANGUAGE plpgsql SECURITY DEFINER;\r\n\r\n-- =====================================================\r\n-- WORLD POLICIES\r\n-- =====================================================\r\n\r\n-- Users can view worlds they own\r\nCREATE POLICY \"world_select_owner\"\r\n    ON public.worlds FOR SELECT\r\n    USING (owner_id = auth.uid());\r\n\r\n-- Users can view public worlds  \r\nCREATE POLICY \"world_select_public\"\r\n    ON public.worlds FOR SELECT\r\n    USING (is_public = TRUE);\r\n\r\n-- Users can view worlds they are members of\r\nCREATE POLICY \"world_select_member\"\r\n    ON public.worlds FOR SELECT\r\n    USING (user_has_world_access(id, auth.uid()));\r\n\r\n-- Users can create worlds\r\nCREATE POLICY \"world_insert\"\r\n    ON public.worlds FOR INSERT\r\n    WITH CHECK (owner_id = auth.uid());\r\n\r\n-- Owners can update their worlds\r\nCREATE POLICY \"world_update_owner\"\r\n    ON public.worlds FOR UPDATE\r\n    USING (owner_id = auth.uid());\r\n\r\n-- Owners can delete their worlds\r\nCREATE POLICY \"world_delete_owner\"\r\n    ON public.worlds FOR DELETE\r\n    USING (owner_id = auth.uid());\r\n\r\n-- =====================================================\r\n-- WORLD MEMBER POLICIES\r\n-- =====================================================\r\n\r\n-- Users can view memberships for accessible worlds\r\nCREATE POLICY \"world_member_select\"\r\n    ON public.world_members FOR SELECT\r\n    USING (user_has_world_access(world_id, auth.uid()));\r\n\r\n-- Users can manage memberships for worlds they own\r\nCREATE POLICY \"world_member_manage_owner\"\r\n    ON public.world_members FOR ALL\r\n    USING (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        )\r\n    );\r\n\r\n-- =====================================================\r\n-- FOLDER POLICIES\r\n-- =====================================================\r\n\r\nCREATE POLICY \"Users can view folders in accessible worlds\"\r\n    ON public.folders FOR SELECT\r\n    USING (user_has_world_access(world_id, auth.uid()));\r\n\r\nCREATE POLICY \"Users can create folders in editable worlds\"\r\n    ON public.folders FOR INSERT\r\n    WITH CHECK (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"Users can update folders in editable worlds\"\r\n    ON public.folders FOR UPDATE\r\n    USING (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"Users can delete folders in editable worlds\"\r\n    ON public.folders FOR DELETE\r\n    USING (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\r\n        )\r\n    );\r\n\r\n-- =====================================================\r\n-- TEMPLATE POLICIES  \r\n-- =====================================================\r\n\r\nCREATE POLICY \"Users can view accessible templates\"\r\n    ON public.templates FOR SELECT\r\n    USING (\r\n        world_id IS NULL OR -- System templates\r\n        user_has_world_access(world_id, auth.uid())\r\n    );\r\n\r\nCREATE POLICY \"Users can create templates in editable worlds\"\r\n    ON public.templates FOR INSERT\r\n    WITH CHECK (\r\n        world_id IS NULL OR -- System templates (restricted in app logic)\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"Users can update templates in editable worlds\"\r\n    ON public.templates FOR UPDATE\r\n    USING (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"Users can delete templates in editable worlds\"\r\n    ON public.templates FOR DELETE\r\n    USING (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\r\n        )\r\n    );\r\n\r\n-- =====================================================\r\n-- ENTITY POLICIES\r\n-- =====================================================\r\n\r\nCREATE POLICY \"Users can view entities in accessible worlds\"\r\n    ON public.entities FOR SELECT\r\n    USING (user_has_world_access(world_id, auth.uid()));\r\n\r\nCREATE POLICY \"Users can create entities in editable worlds\"\r\n    ON public.entities FOR INSERT\r\n    WITH CHECK (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"Users can update entities in editable worlds\"\r\n    ON public.entities FOR UPDATE\r\n    USING (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"Users can delete entities in editable worlds\"\r\n    ON public.entities FOR DELETE\r\n    USING (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\r\n        )\r\n    );\r\n\r\n-- =====================================================\r\n-- RELATIONSHIP POLICIES\r\n-- =====================================================\r\n\r\nCREATE POLICY \"Users can view relationships in accessible worlds\"\r\n    ON public.relationships FOR SELECT\r\n    USING (user_has_world_access(world_id, auth.uid()));\r\n\r\nCREATE POLICY \"Users can create relationships in editable worlds\"\r\n    ON public.relationships FOR INSERT\r\n    WITH CHECK (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"Users can update relationships in editable worlds\"\r\n    ON public.relationships FOR UPDATE\r\n    USING (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"Users can delete relationships in editable worlds\"\r\n    ON public.relationships FOR DELETE\r\n    USING (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\r\n        )\r\n    );\r\n\r\n-- =====================================================\r\n-- WORLD BAN POLICIES\r\n-- =====================================================\r\n\r\nCREATE POLICY \"Users can view bans for worlds they own\"\r\n    ON public.world_bans FOR SELECT\r\n    USING (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"World owners and admins can manage bans\"\r\n    ON public.world_bans FOR ALL\r\n    USING (\r\n        world_id IN (\r\n            SELECT id FROM public.worlds WHERE owner_id = auth.uid()\r\n        ) OR\r\n        world_id IN (\r\n            SELECT world_id FROM public.world_members \r\n            WHERE user_id = auth.uid() AND role IN ('admin')\r\n        )\r\n    );\r\n",
      "size": 10287
    },
    {
      "filename": "20250907020000_add_invites_activity_files.sql",
      "timestamp": "20250907020000",
      "name": "add invites activity files",
      "path": "supabase\\migrations\\20250907020000_add_invites_activity_files.sql",
      "content": "-- Additional tables and indexes to support invites, activity logs, files,\n-- plus useful constraints and indexes.\n\n-- ================================\n-- WORLD INVITES\n-- ================================\n\nCREATE TABLE IF NOT EXISTS public.world_invites (\n  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\n  world_id UUID REFERENCES public.worlds(id) ON DELETE CASCADE NOT NULL,\n  email TEXT NOT NULL,\n  role TEXT NOT NULL CHECK (role IN ('admin', 'editor', 'viewer')),\n  invited_by UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  token TEXT UNIQUE NOT NULL,\n  expires_at TIMESTAMPTZ NOT NULL,\n  accepted_at TIMESTAMPTZ,\n  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL\n);\n\nALTER TABLE public.world_invites ENABLE ROW LEVEL SECURITY;\n\n-- View invites relevant to user (by email) or worlds they own/admin\nCREATE POLICY \"invites_select\"\n  ON public.world_invites FOR SELECT\n  USING (\n    lower(email) = lower(coalesce(auth.jwt() ->> 'email', '')) OR\n    world_id IN (\n      SELECT id FROM public.worlds WHERE owner_id = auth.uid()\n    ) OR world_id IN (\n      SELECT world_id FROM public.world_members WHERE user_id = auth.uid() AND role IN ('admin')\n    )\n  );\n\n-- Owners/admins can create invites\nCREATE POLICY \"invites_insert\"\n  ON public.world_invites FOR INSERT\n  WITH CHECK (\n    world_id IN (\n      SELECT id FROM public.worlds WHERE owner_id = auth.uid()\n    ) OR world_id IN (\n      SELECT world_id FROM public.world_members WHERE user_id = auth.uid() AND role IN ('admin')\n    )\n  );\n\n-- Owners/admins can update invites (manage)\nCREATE POLICY \"invites_update_manage\"\n  ON public.world_invites FOR UPDATE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = auth.uid()) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members\n      WHERE user_id = auth.uid() AND role = 'admin'\n    )\n  )\n  WITH CHECK (true);\n\n-- Invited user can mark their invite accepted\nCREATE POLICY \"invites_update_accept\"\n  ON public.world_invites FOR UPDATE\n  USING (lower(email) = lower(coalesce(auth.jwt() ->> 'email', '')))\n  WITH CHECK (lower(email) = lower(coalesce(auth.jwt() ->> 'email', '')));\n\n-- Owners/admins can delete invites\nCREATE POLICY \"invites_delete\"\n  ON public.world_invites FOR DELETE\n  USING (\n    world_id IN (\n      SELECT id FROM public.worlds WHERE owner_id = auth.uid()\n    ) OR world_id IN (\n      SELECT world_id FROM public.world_members WHERE user_id = auth.uid() AND role IN ('admin')\n    )\n  );\n\nCREATE INDEX IF NOT EXISTS idx_world_invites_world_id ON public.world_invites(world_id);\nCREATE INDEX IF NOT EXISTS idx_world_invites_email ON public.world_invites(email);\n\n-- ================================\n-- ACTIVITY LOGS\n-- ================================\n\nCREATE TABLE IF NOT EXISTS public.activity_logs (\n  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\n  world_id UUID REFERENCES public.worlds(id) ON DELETE CASCADE NOT NULL,\n  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,\n  action TEXT NOT NULL,\n  entity_type TEXT,\n  entity_id UUID,\n  details JSONB DEFAULT '{}'::jsonb,\n  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL\n);\n\nALTER TABLE public.activity_logs ENABLE ROW LEVEL SECURITY;\n\n-- Users can view activity for accessible worlds\nCREATE POLICY \"activity_select\"\n  ON public.activity_logs FOR SELECT\n  USING (\n    world_id IN (\n      SELECT id FROM public.worlds WHERE owner_id = auth.uid()\n    ) OR world_id IN (\n      SELECT world_id FROM public.world_members WHERE user_id = auth.uid()\n    )\n  );\n\n-- Service/system may insert logs; leave permissive (adjust as needed)\nCREATE POLICY \"activity_insert\"\n  ON public.activity_logs FOR INSERT\n  WITH CHECK (true);\n\nCREATE INDEX IF NOT EXISTS idx_activity_logs_world_id ON public.activity_logs(world_id);\nCREATE INDEX IF NOT EXISTS idx_activity_logs_user_id ON public.activity_logs(user_id);\nCREATE INDEX IF NOT EXISTS idx_activity_logs_created_at ON public.activity_logs(created_at);\n\n-- ================================\n-- WORLD FILES (metadata only; pair with Supabase Storage)\n-- ================================\n\nCREATE TABLE IF NOT EXISTS public.world_files (\n  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\n  world_id UUID REFERENCES public.worlds(id) ON DELETE CASCADE NOT NULL,\n  file_name TEXT NOT NULL,\n  file_path TEXT NOT NULL,\n  file_size INTEGER,\n  mime_type TEXT,\n  uploaded_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,\n  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL\n);\n\nALTER TABLE public.world_files ENABLE ROW LEVEL SECURITY;\n\n-- View files in accessible worlds\nCREATE POLICY \"files_select\"\n  ON public.world_files FOR SELECT\n  USING (\n    world_id IN (\n      SELECT id FROM public.worlds WHERE owner_id = auth.uid()\n    ) OR world_id IN (\n      SELECT world_id FROM public.world_members WHERE user_id = auth.uid()\n    )\n  );\n\n-- Upload files to editable worlds\nCREATE POLICY \"files_insert\"\n  ON public.world_files FOR INSERT\n  WITH CHECK (\n    world_id IN (\n      SELECT id FROM public.worlds WHERE owner_id = auth.uid()\n    ) OR world_id IN (\n      SELECT world_id FROM public.world_members WHERE user_id = auth.uid() AND role IN ('admin', 'editor')\n    )\n  );\n\n-- Delete own files or owners\nCREATE POLICY \"files_delete\"\n  ON public.world_files FOR DELETE\n  USING (\n    uploaded_by = auth.uid() OR world_id IN (\n      SELECT id FROM public.worlds WHERE owner_id = auth.uid()\n    )\n  );\n\nCREATE INDEX IF NOT EXISTS idx_world_files_world_id ON public.world_files(world_id);\n\n-- ================================\n-- RELATIONSHIPS: de-duplicate constraint\n-- ================================\n\n-- Prefer a unique index to avoid duplicate relationship triplets\nCREATE UNIQUE INDEX IF NOT EXISTS ux_relationships_pair_type\n  ON public.relationships(from_entity_id, to_entity_id, relationship_type);\n\n-- ================================\n-- PERFORMANCE-ORIENTED INDEXES\n-- ================================\n\n-- Speed up common filters\nCREATE INDEX IF NOT EXISTS idx_worlds_is_archived ON public.worlds(is_archived);\nCREATE INDEX IF NOT EXISTS idx_entities_world_updated_at ON public.entities(world_id, updated_at DESC);\n\n-- Template lookup by name + scope (used by seeding/upserts)\nCREATE INDEX IF NOT EXISTS idx_templates_system_name\n  ON public.templates(name) WHERE is_system = TRUE AND world_id IS NULL;\n\nCREATE INDEX IF NOT EXISTS idx_templates_world_name\n  ON public.templates(world_id, name);\n\n-- ================================\n-- INVITE ACCEPTANCE RPC\n-- ================================\n\n-- Accept an invite by token for the currently authenticated user\n-- Grants membership and marks invite as accepted\nCREATE OR REPLACE FUNCTION public.accept_world_invite(invite_token text)\nRETURNS boolean\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  v_email text := lower(coalesce(auth.jwt() ->> 'email', ''));\n  v_user uuid := auth.uid();\n  v_world uuid;\n  v_role text;\nBEGIN\n  -- Validate invite for this user\n  SELECT wi.world_id, wi.role\n    INTO v_world, v_role\n  FROM public.world_invites wi\n  WHERE wi.token = invite_token\n    AND lower(wi.email) = v_email\n    AND wi.accepted_at IS NULL\n    AND wi.expires_at > NOW()\n  LIMIT 1;\n\n  IF v_world IS NULL THEN\n    RETURN FALSE;\n  END IF;\n\n  -- Grant membership (upsert)\n  INSERT INTO public.world_members(world_id, user_id, role)\n  VALUES (v_world, v_user, v_role::public.world_member_role)\n  ON CONFLICT (world_id, user_id)\n  DO UPDATE SET role = EXCLUDED.role;\n\n  -- Mark invite accepted\n  UPDATE public.world_invites\n     SET accepted_at = NOW()\n   WHERE token = invite_token;\n\n  RETURN TRUE;\nEND;\n$$;\n\nGRANT EXECUTE ON FUNCTION public.accept_world_invite(text) TO authenticated;\n",
      "size": 7609
    },
    {
      "filename": "20250907170000_add_storage_policies.sql",
      "timestamp": "20250907170000",
      "name": "add storage policies",
      "path": "supabase\\migrations\\20250907170000_add_storage_policies.sql",
      "content": "-- Create private bucket for world assets and apply RLS policies on storage.objects\n\n-- Create bucket if it does not exist (service role required)\ninsert into storage.buckets (id, name, public)\nvalues ('world-assets', 'world-assets', false)\non conflict (id) do nothing;\n\n-- Ensure RLS is enabled on storage.objects (should be enabled by default)\nalter table storage.objects enable row level security;\n\n-- Allow reading files in the world-assets bucket if user has access to the world\nDO $$ BEGIN\n  EXECUTE 'DROP POLICY \"world-assets read\" ON storage.objects';\nEXCEPTION WHEN undefined_object THEN NULL; END $$;\nCREATE POLICY \"world-assets read\" ON storage.objects\nfor select using (\n  bucket_id = 'world-assets' and\n  exists (\n    select 1 from public.world_files wf\n    where wf.file_path = storage.objects.name\n      and (\n        wf.world_id in (select id from public.worlds where owner_id = auth.uid())\n        or wf.world_id in (select world_id from public.world_members where user_id = auth.uid())\n      )\n  )\n);\n\n-- Allow inserting (uploading) files into world-assets when metadata exists\n-- and the user can edit the target world\nDO $$ BEGIN\n  EXECUTE 'DROP POLICY \"world-assets insert\" ON storage.objects';\nEXCEPTION WHEN undefined_object THEN NULL; END $$;\nCREATE POLICY \"world-assets insert\" ON storage.objects\nfor insert with check (\n  bucket_id = 'world-assets' and\n  exists (\n    select 1 from public.world_files wf\n    where wf.file_path = storage.objects.name\n      and (\n        wf.world_id in (select id from public.worlds where owner_id = auth.uid())\n        or wf.world_id in (\n          select world_id from public.world_members where user_id = auth.uid() and role in ('admin','editor')\n        )\n      )\n      and (wf.uploaded_by is null or wf.uploaded_by = auth.uid())\n  )\n);\n\n-- Allow deleting files the user uploaded or world owners/admins\nDO $$ BEGIN\n  EXECUTE 'DROP POLICY \"world-assets delete\" ON storage.objects';\nEXCEPTION WHEN undefined_object THEN NULL; END $$;\nCREATE POLICY \"world-assets delete\" ON storage.objects\nfor delete using (\n  bucket_id = 'world-assets' and\n  exists (\n    select 1 from public.world_files wf\n    where wf.file_path = storage.objects.name\n      and (\n        wf.uploaded_by = auth.uid()\n        or wf.world_id in (select id from public.worlds where owner_id = auth.uid())\n        or wf.world_id in (\n          select world_id from public.world_members where user_id = auth.uid() and role = 'admin'\n        )\n      )\n  )\n);\n\n-- Note: Policy evaluation assumes world_files.file_path matches storage.objects.name (path within the bucket)\n-- Recommended convention: file_path like 'world/<world_id>/.../filename.ext'\n",
      "size": 2672
    },
    {
      "filename": "20250907173500_optimize_rls_auth_calls.sql",
      "timestamp": "20250907173500",
      "name": "optimize rls auth calls",
      "path": "supabase\\migrations\\20250907173500_optimize_rls_auth_calls.sql",
      "content": "-- Optimize RLS policies by calling auth.* via scalar subselects\n-- and consolidate duplicate permissive SELECT policies.\n-- See: https://supabase.com/docs/guides/database/postgres/row-level-security#call-functions-with-select\n\n-- NOTE: This migration only changes policy expressions and drops redundant policies.\n-- It does not broaden access; it reduces per-row re-evaluation cost and removes\n-- duplicate permissive SELECT policies for better performance.\n\n-- =============================\n-- PROFILES\n-- =============================\nDROP POLICY IF EXISTS \"Users can view their own profile\" ON public.profiles;\nCREATE POLICY \"Users can view their own profile\"\n  ON public.profiles FOR SELECT\n  USING ((SELECT auth.uid()) = id);\n\nDROP POLICY IF EXISTS \"Users can update their own profile\" ON public.profiles;\nCREATE POLICY \"Users can update their own profile\"\n  ON public.profiles FOR UPDATE\n  USING ((SELECT auth.uid()) = id);\n\n-- =============================\n-- WORLDS\n-- =============================\n-- Keep a single SELECT policy that already covers ownership/public/membership via helper\n-- Drop redundant SELECT policies if they exist\nDROP POLICY IF EXISTS \"world_select_owner\" ON public.worlds;\nDROP POLICY IF EXISTS \"world_select_public\" ON public.worlds;\n\n-- Ensure the remaining SELECT policy uses scalar subselect\nDROP POLICY IF EXISTS \"world_select_member\" ON public.worlds;\nCREATE POLICY \"world_select_member\"\n  ON public.worlds FOR SELECT\n  USING (user_has_world_access(id, (SELECT auth.uid())));\n\n-- Insert/Update/Delete use scalar subselects\nDROP POLICY IF EXISTS \"world_insert\" ON public.worlds;\nCREATE POLICY \"world_insert\" ON public.worlds\n  FOR INSERT\n  WITH CHECK ((SELECT auth.uid()) = owner_id);\n\nDROP POLICY IF EXISTS \"world_update_owner\" ON public.worlds;\nCREATE POLICY \"world_update_owner\" ON public.worlds\n  FOR UPDATE\n  USING ((SELECT auth.uid()) = owner_id);\n\nDROP POLICY IF EXISTS \"world_delete_owner\" ON public.worlds;\nCREATE POLICY \"world_delete_owner\" ON public.worlds\n  FOR DELETE\n  USING ((SELECT auth.uid()) = owner_id);\n\n-- =============================\n-- WORLD MEMBERS\n-- =============================\n-- View memberships for accessible worlds\nDROP POLICY IF EXISTS \"world_member_select\" ON public.world_members;\nCREATE POLICY \"world_member_select\"\n  ON public.world_members FOR SELECT\n  USING (user_has_world_access(world_id, (SELECT auth.uid())));\n\n-- Replace FOR ALL manage policy with per-action policies that do not include SELECT\nDROP POLICY IF EXISTS \"world_member_manage_owner\" ON public.world_members;\n\nCREATE POLICY \"world_member_insert_owner\"\n  ON public.world_members FOR INSERT\n  WITH CHECK (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid()))\n  );\n\nCREATE POLICY \"world_member_update_owner\"\n  ON public.world_members FOR UPDATE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid()))\n  );\n\nCREATE POLICY \"world_member_delete_owner\"\n  ON public.world_members FOR DELETE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid()))\n  );\n\n-- =============================\n-- FOLDERS\n-- =============================\n-- Drop duplicate policies introduced elsewhere and keep per-action ones\nDROP POLICY IF EXISTS \"folder_select\" ON public.folders;\nDROP POLICY IF EXISTS \"folder_modify\" ON public.folders;\n\nDROP POLICY IF EXISTS \"Users can view folders in accessible worlds\" ON public.folders;\nCREATE POLICY \"Users can view folders in accessible worlds\"\n  ON public.folders FOR SELECT\n  USING (user_has_world_access(world_id, (SELECT auth.uid())));\n\nDROP POLICY IF EXISTS \"Users can create folders in editable worlds\" ON public.folders;\nCREATE POLICY \"Users can create folders in editable worlds\"\n  ON public.folders FOR INSERT\n  WITH CHECK (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\nDROP POLICY IF EXISTS \"Users can update folders in editable worlds\" ON public.folders;\nCREATE POLICY \"Users can update folders in editable worlds\"\n  ON public.folders FOR UPDATE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\nDROP POLICY IF EXISTS \"Users can delete folders in editable worlds\" ON public.folders;\nCREATE POLICY \"Users can delete folders in editable worlds\"\n  ON public.folders FOR DELETE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\n-- =============================\n-- TEMPLATES\n-- =============================\n-- Drop duplicate short-named policies and use detailed per-action ones\nDROP POLICY IF EXISTS \"template_select\" ON public.templates;\nDROP POLICY IF EXISTS \"template_modify\" ON public.templates;\n\nDROP POLICY IF EXISTS \"Users can view accessible templates\" ON public.templates;\nCREATE POLICY \"Users can view accessible templates\"\n  ON public.templates FOR SELECT\n  USING (\n    world_id IS NULL OR\n    user_has_world_access(world_id, (SELECT auth.uid()))\n  );\n\nDROP POLICY IF EXISTS \"Users can create templates in editable worlds\" ON public.templates;\nCREATE POLICY \"Users can create templates in editable worlds\"\n  ON public.templates FOR INSERT\n  WITH CHECK (\n    world_id IS NULL OR\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\nDROP POLICY IF EXISTS \"Users can update templates in editable worlds\" ON public.templates;\nCREATE POLICY \"Users can update templates in editable worlds\"\n  ON public.templates FOR UPDATE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\nDROP POLICY IF EXISTS \"Users can delete templates in editable worlds\" ON public.templates;\nCREATE POLICY \"Users can delete templates in editable worlds\"\n  ON public.templates FOR DELETE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\n-- =============================\n-- ENTITIES\n-- =============================\nDROP POLICY IF EXISTS \"entity_select\" ON public.entities;\nDROP POLICY IF EXISTS \"entity_modify\" ON public.entities;\n\nDROP POLICY IF EXISTS \"Users can view entities in accessible worlds\" ON public.entities;\nCREATE POLICY \"Users can view entities in accessible worlds\"\n  ON public.entities FOR SELECT\n  USING (user_has_world_access(world_id, (SELECT auth.uid())));\n\nDROP POLICY IF EXISTS \"Users can create entities in editable worlds\" ON public.entities;\nCREATE POLICY \"Users can create entities in editable worlds\"\n  ON public.entities FOR INSERT\n  WITH CHECK (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\nDROP POLICY IF EXISTS \"Users can update entities in editable worlds\" ON public.entities;\nCREATE POLICY \"Users can update entities in editable worlds\"\n  ON public.entities FOR UPDATE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\nDROP POLICY IF EXISTS \"Users can delete entities in editable worlds\" ON public.entities;\nCREATE POLICY \"Users can delete entities in editable worlds\"\n  ON public.entities FOR DELETE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\n-- =============================\n-- RELATIONSHIPS\n-- =============================\nDROP POLICY IF EXISTS \"relationship_select\" ON public.relationships;\nDROP POLICY IF EXISTS \"relationship_modify\" ON public.relationships;\n\nDROP POLICY IF EXISTS \"Users can view relationships in accessible worlds\" ON public.relationships;\nCREATE POLICY \"Users can view relationships in accessible worlds\"\n  ON public.relationships FOR SELECT\n  USING (user_has_world_access(world_id, (SELECT auth.uid())));\n\nDROP POLICY IF EXISTS \"Users can create relationships in editable worlds\" ON public.relationships;\nCREATE POLICY \"Users can create relationships in editable worlds\"\n  ON public.relationships FOR INSERT\n  WITH CHECK (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\nDROP POLICY IF EXISTS \"Users can update relationships in editable worlds\" ON public.relationships;\nCREATE POLICY \"Users can update relationships in editable worlds\"\n  ON public.relationships FOR UPDATE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\nDROP POLICY IF EXISTS \"Users can delete relationships in editable worlds\" ON public.relationships;\nCREATE POLICY \"Users can delete relationships in editable worlds\"\n  ON public.relationships FOR DELETE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\n-- =============================\n-- WORLD BANS\n-- =============================\n-- Remove any FOR ALL manage policies and split into per-action\nDROP POLICY IF EXISTS \"ban_manage\" ON public.world_bans;\nDROP POLICY IF EXISTS \"World owners and admins can manage bans\" ON public.world_bans;\n\nDROP POLICY IF EXISTS \"Users can view bans for worlds they own\" ON public.world_bans;\nCREATE POLICY \"Users can view bans for worlds they own\"\n  ON public.world_bans FOR SELECT\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid()))\n  );\n\nCREATE POLICY \"ban_insert_manage\" ON public.world_bans\n  FOR INSERT\n  WITH CHECK (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin')\n    )\n  );\n\nCREATE POLICY \"ban_update_manage\" ON public.world_bans\n  FOR UPDATE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin')\n    )\n  );\n\nCREATE POLICY \"ban_delete_manage\" ON public.world_bans\n  FOR DELETE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin')\n    )\n  );\n\n-- =============================\n-- INVITES / ACTIVITY / FILES\n-- =============================\n-- Wrap auth.* in scalar subselects in these policies too\n\n-- world_invites\nDROP POLICY IF EXISTS \"Invites update (manage or accept)\" ON public.world_invites;\nDROP POLICY IF EXISTS \"invites_select\" ON public.world_invites;\nCREATE POLICY \"invites_select\" ON public.world_invites\n  FOR SELECT\n  USING (\n    lower(email) = lower(coalesce((SELECT auth.jwt()) ->> 'email', '')) OR\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin')\n    )\n  );\n\nDROP POLICY IF EXISTS \"invites_insert\" ON public.world_invites;\nCREATE POLICY \"invites_insert\" ON public.world_invites\n  FOR INSERT\n  WITH CHECK (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin')\n    )\n  );\n\nDROP POLICY IF EXISTS \"invites_update_manage\" ON public.world_invites;\nCREATE POLICY \"invites_update_manage\" ON public.world_invites\n  FOR UPDATE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role = 'admin'\n    )\n  )\n  WITH CHECK (TRUE);\n\nDROP POLICY IF EXISTS \"invites_update_accept\" ON public.world_invites;\nCREATE POLICY \"invites_update_accept\" ON public.world_invites\n  FOR UPDATE\n  USING (lower(email) = lower(coalesce((SELECT auth.jwt()) ->> 'email', '')))\n  WITH CHECK (lower(email) = lower(coalesce((SELECT auth.jwt()) ->> 'email', '')));\n\nDROP POLICY IF EXISTS \"invites_delete\" ON public.world_invites;\nCREATE POLICY \"invites_delete\" ON public.world_invites\n  FOR DELETE\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin')\n    )\n  );\n\n-- activity_logs\nDROP POLICY IF EXISTS \"activity_select\" ON public.activity_logs;\nCREATE POLICY \"activity_select\" ON public.activity_logs\n  FOR SELECT\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid())\n    )\n  );\n\n-- world_files\nDROP POLICY IF EXISTS \"files_select\" ON public.world_files;\nCREATE POLICY \"files_select\" ON public.world_files\n  FOR SELECT\n  USING (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid())\n    )\n  );\n\nDROP POLICY IF EXISTS \"files_insert\" ON public.world_files;\nCREATE POLICY \"files_insert\" ON public.world_files\n  FOR INSERT\n  WITH CHECK (\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid())) OR\n    world_id IN (\n      SELECT world_id FROM public.world_members \n      WHERE user_id = (SELECT auth.uid()) AND role IN ('admin', 'editor')\n    )\n  );\n\nDROP POLICY IF EXISTS \"files_delete\" ON public.world_files;\nCREATE POLICY \"files_delete\" ON public.world_files\n  FOR DELETE\n  USING (\n    uploaded_by = (SELECT auth.uid()) OR\n    world_id IN (SELECT id FROM public.worlds WHERE owner_id = (SELECT auth.uid()))\n  );\n",
      "size": 15387
    },
    {
      "filename": "20250908120000_extend_worlds_fields.sql",
      "timestamp": "20250908120000",
      "name": "extend worlds fields",
      "path": "supabase\\migrations\\20250908120000_extend_worlds_fields.sql",
      "content": "-- Extend public.worlds with structured fields used during world creation\n-- Safe to run multiple times (IF NOT EXISTS guards)\n\nALTER TABLE public.worlds\n  ADD COLUMN IF NOT EXISTS logline TEXT,\n  ADD COLUMN IF NOT EXISTS genre_blend TEXT[] DEFAULT ARRAY[]::TEXT[],\n  ADD COLUMN IF NOT EXISTS overall_tone TEXT,\n  ADD COLUMN IF NOT EXISTS key_themes TEXT[] DEFAULT ARRAY[]::TEXT[],\n  ADD COLUMN IF NOT EXISTS audience_rating TEXT,\n  ADD COLUMN IF NOT EXISTS scope_scale TEXT,\n  ADD COLUMN IF NOT EXISTS technology_level TEXT[] DEFAULT ARRAY[]::TEXT[],\n  ADD COLUMN IF NOT EXISTS magic_level TEXT[] DEFAULT ARRAY[]::TEXT[],\n  ADD COLUMN IF NOT EXISTS cosmology_model TEXT,\n  ADD COLUMN IF NOT EXISTS climate_biomes TEXT[] DEFAULT ARRAY[]::TEXT[],\n  ADD COLUMN IF NOT EXISTS calendar_timekeeping TEXT,\n  ADD COLUMN IF NOT EXISTS societal_overview TEXT,\n  ADD COLUMN IF NOT EXISTS conflict_drivers TEXT[] DEFAULT ARRAY[]::TEXT[],\n  ADD COLUMN IF NOT EXISTS rules_constraints TEXT,\n  ADD COLUMN IF NOT EXISTS aesthetic_direction TEXT;\n\n-- Optional: lightweight indexes for common filters (uncomment if needed)\nCREATE INDEX IF NOT EXISTS idx_worlds_overall_tone ON public.worlds (overall_tone);\nCREATE INDEX IF NOT EXISTS idx_worlds_audience_rating ON public.worlds (audience_rating);\nCREATE INDEX IF NOT EXISTS idx_worlds_scope_scale ON public.worlds (scope_scale);\n\nCOMMENT ON COLUMN public.worlds.logline IS 'One-line premise for the world';\nCOMMENT ON COLUMN public.worlds.genre_blend IS 'Primary genres associated with the world';\nCOMMENT ON COLUMN public.worlds.overall_tone IS 'Overall tone (e.g., Bright, Dark)';\nCOMMENT ON COLUMN public.worlds.key_themes IS 'Key thematic elements';\nCOMMENT ON COLUMN public.worlds.audience_rating IS 'Intended audience (e.g., Teen, Mature)';\nCOMMENT ON COLUMN public.worlds.scope_scale IS 'Narrative/setting scope (e.g., Planetary)';\nCOMMENT ON COLUMN public.worlds.technology_level IS 'Technology levels present';\nCOMMENT ON COLUMN public.worlds.magic_level IS 'Magic levels present';\nCOMMENT ON COLUMN public.worlds.cosmology_model IS 'Cosmology description/model';\nCOMMENT ON COLUMN public.worlds.climate_biomes IS 'Dominant climates/biomes';\nCOMMENT ON COLUMN public.worlds.calendar_timekeeping IS 'Calendar and timekeeping overview';\nCOMMENT ON COLUMN public.worlds.societal_overview IS 'Societal structure overview';\nCOMMENT ON COLUMN public.worlds.conflict_drivers IS 'Primary drivers of conflict';\nCOMMENT ON COLUMN public.worlds.rules_constraints IS 'Rules or constraints governing the setting';\nCOMMENT ON COLUMN public.worlds.aesthetic_direction IS 'Aesthetic/style direction';\n\n",
      "size": 2628
    },
    {
      "filename": "20250908130000_remove_user_id_from_worlds.sql",
      "timestamp": "20250908130000",
      "name": "remove user id from worlds",
      "path": "supabase\\migrations\\20250908130000_remove_user_id_from_worlds.sql",
      "content": "-- Remove the redundant user_id column from worlds table\r\n-- The table should only use owner_id for consistency\r\n\r\nALTER TABLE public.worlds DROP COLUMN IF EXISTS user_id;\r\n",
      "size": 173
    },
    {
      "filename": "20250908170000_performance_indexes.sql",
      "timestamp": "20250908170000",
      "name": "performance indexes",
      "path": "supabase\\migrations\\20250908170000_performance_indexes.sql",
      "content": "-- Migration for Step 7: Database Performance & Indexing\r\n-- Adds indexes for common query patterns and performance\r\n\r\n-- Entities: index for world_id and updated_at DESC\r\nCREATE INDEX CONCURRENTLY idx_entities_world_updated \r\n  ON entities(world_id, updated_at DESC);\r\n\r\n-- Templates: index for name where is_system = true\r\nCREATE INDEX CONCURRENTLY idx_templates_system_name \r\n  ON templates(name) WHERE is_system = true;\r\n\r\n-- Add additional composite indexes for common filter combinations as needed\r\n-- Example: Composite index for entities by world_id, template_id, and updated_at\r\nCREATE INDEX CONCURRENTLY idx_entities_world_template_updated \r\n  ON entities(world_id, template_id, updated_at DESC);\r\n\r\n-- Example: Composite index for templates by world_id, category, and name\r\nCREATE INDEX CONCURRENTLY idx_templates_world_category_name \r\n  ON templates(world_id, category, name);\r\n\r\n-- Document expected query performance SLAs in DATABASE_PERFORMANCE.md\r\n-- (See checklist for details)\r\n",
      "size": 996
    },
    {
      "filename": "20250908230000_enhanced_rate_limiting.sql",
      "timestamp": "20250908230000",
      "name": "enhanced rate limiting",
      "path": "supabase\\migrations\\20250908230000_enhanced_rate_limiting.sql",
      "content": "-- Migration: Enhanced Rate Limiting with Database Backend\r\n-- This migration creates tables for scalable rate limiting\r\n\r\n-- Create rate_limits table for tracking API usage\r\nCREATE TABLE IF NOT EXISTS rate_limits (\r\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  key_hash TEXT NOT NULL, -- Hashed combination of IP + endpoint for privacy\r\n  bucket TEXT NOT NULL, -- Rate limit bucket (e.g., 'invites.create', 'admin.seed')\r\n  count INTEGER NOT NULL DEFAULT 1,\r\n  window_start TIMESTAMPTZ NOT NULL,\r\n  window_end TIMESTAMPTZ NOT NULL,\r\n  created_at TIMESTAMPTZ DEFAULT NOW(),\r\n  updated_at TIMESTAMPTZ DEFAULT NOW()\r\n);\r\n\r\n-- Create unique index for efficient lookups\r\nCREATE UNIQUE INDEX IF NOT EXISTS idx_rate_limits_key_bucket_window \r\nON rate_limits(key_hash, bucket, window_start);\r\n\r\n-- Create index for cleanup operations\r\nCREATE INDEX IF NOT EXISTS idx_rate_limits_window_end \r\nON rate_limits(window_end) WHERE window_end < NOW();\r\n\r\n-- Enable RLS\r\nALTER TABLE rate_limits ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Create policy for system-only access (rate limiting is system function)\r\nCREATE POLICY rate_limits_system_only ON rate_limits\r\nFOR ALL \r\nTO service_role\r\nUSING (true)\r\nWITH CHECK (true);\r\n\r\n-- Create function to clean up expired rate limit records\r\nCREATE OR REPLACE FUNCTION cleanup_expired_rate_limits()\r\nRETURNS INTEGER AS $$\r\nDECLARE\r\n  deleted_count INTEGER;\r\nBEGIN\r\n  DELETE FROM rate_limits WHERE window_end < NOW() - INTERVAL '1 hour';\r\n  GET DIAGNOSTICS deleted_count = ROW_COUNT;\r\n  RETURN deleted_count;\r\nEND;\r\n$$ LANGUAGE plpgsql SECURITY DEFINER;\r\n\r\n-- Create function for atomic rate limit checking and incrementing\r\nCREATE OR REPLACE FUNCTION check_rate_limit(\r\n  p_key_hash TEXT,\r\n  p_bucket TEXT,\r\n  p_max_requests INTEGER,\r\n  p_window_seconds INTEGER\r\n)\r\nRETURNS JSON AS $$\r\nDECLARE\r\n  current_window_start TIMESTAMPTZ;\r\n  current_window_end TIMESTAMPTZ;\r\n  current_count INTEGER;\r\n  remaining INTEGER;\r\n  reset_time TIMESTAMPTZ;\r\n  result JSON;\r\nBEGIN\r\n  -- Calculate current window\r\n  current_window_start := date_trunc('minute', NOW()) + \r\n    INTERVAL '1 minute' * FLOOR(EXTRACT(EPOCH FROM (NOW() - date_trunc('minute', NOW()))) / p_window_seconds);\r\n  current_window_end := current_window_start + INTERVAL '1 second' * p_window_seconds;\r\n  \r\n  -- Try to get existing record for this window\r\n  SELECT count, window_end INTO current_count, reset_time\r\n  FROM rate_limits \r\n  WHERE key_hash = p_key_hash \r\n    AND bucket = p_bucket \r\n    AND window_start = current_window_start;\r\n  \r\n  IF NOT FOUND THEN\r\n    -- No existing record, create new one\r\n    INSERT INTO rate_limits (key_hash, bucket, count, window_start, window_end)\r\n    VALUES (p_key_hash, p_bucket, 1, current_window_start, current_window_end);\r\n    \r\n    current_count := 1;\r\n    reset_time := current_window_end;\r\n  ELSE\r\n    -- Check if limit exceeded\r\n    IF current_count >= p_max_requests THEN\r\n      remaining := 0;\r\n    ELSE\r\n      -- Increment counter\r\n      UPDATE rate_limits \r\n      SET count = count + 1, updated_at = NOW()\r\n      WHERE key_hash = p_key_hash \r\n        AND bucket = p_bucket \r\n        AND window_start = current_window_start;\r\n      \r\n      current_count := current_count + 1;\r\n    END IF;\r\n  END IF;\r\n  \r\n  remaining := GREATEST(0, p_max_requests - current_count);\r\n  \r\n  -- Build result\r\n  result := json_build_object(\r\n    'allowed', current_count <= p_max_requests,\r\n    'count', current_count,\r\n    'remaining', remaining,\r\n    'reset_time', EXTRACT(EPOCH FROM reset_time)::INTEGER,\r\n    'retry_after', CASE \r\n      WHEN current_count > p_max_requests \r\n      THEN EXTRACT(EPOCH FROM (reset_time - NOW()))::INTEGER \r\n      ELSE 0 \r\n    END\r\n  );\r\n  \r\n  RETURN result;\r\nEND;\r\n$$ LANGUAGE plpgsql SECURITY DEFINER;\r\n\r\n-- Create rate limit configuration table for dynamic configuration\r\nCREATE TABLE IF NOT EXISTS rate_limit_configs (\r\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  bucket TEXT UNIQUE NOT NULL,\r\n  max_requests INTEGER NOT NULL,\r\n  window_seconds INTEGER NOT NULL,\r\n  description TEXT,\r\n  is_active BOOLEAN DEFAULT true,\r\n  created_at TIMESTAMPTZ DEFAULT NOW(),\r\n  updated_at TIMESTAMPTZ DEFAULT NOW()\r\n);\r\n\r\n-- Enable RLS for configs\r\nALTER TABLE rate_limit_configs ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Create policy for system access to configs\r\nCREATE POLICY rate_limit_configs_system_only ON rate_limit_configs\r\nFOR ALL \r\nTO service_role\r\nUSING (true)\r\nWITH CHECK (true);\r\n\r\n-- Insert default rate limit configurations\r\nINSERT INTO rate_limit_configs (bucket, max_requests, window_seconds, description) VALUES\r\n  ('invites.create', 10, 60, 'Invite creation rate limit'),\r\n  ('admin.seed', 2, 60, 'Admin seeding operations'),\r\n  ('auth.login', 5, 300, 'Authentication attempts'),\r\n  ('auth.register', 3, 300, 'Registration attempts'),\r\n  ('api.general', 100, 60, 'General API rate limit'),\r\n  ('upload.files', 20, 60, 'File upload rate limit'),\r\n  ('worlds.create', 5, 300, 'World creation rate limit'),\r\n  ('entities.create', 50, 60, 'Entity creation rate limit')\r\nON CONFLICT (bucket) DO NOTHING;\r\n\r\n-- Create indexes for efficient configuration lookups\r\nCREATE INDEX IF NOT EXISTS idx_rate_limit_configs_bucket_active \r\nON rate_limit_configs(bucket) WHERE is_active = true;\r\n\r\n-- Update function to automatically update the updated_at timestamp\r\nCREATE OR REPLACE FUNCTION update_updated_at_column()\r\nRETURNS TRIGGER AS $$\r\nBEGIN\r\n  NEW.updated_at = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$$ LANGUAGE plpgsql;\r\n\r\n-- Create triggers for automatic timestamp updates\r\nCREATE TRIGGER update_rate_limits_updated_at \r\n  BEFORE UPDATE ON rate_limits\r\n  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\r\n\r\nCREATE TRIGGER update_rate_limit_configs_updated_at \r\n  BEFORE UPDATE ON rate_limit_configs\r\n  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\r\n\r\n-- Create cleanup job (to be called periodically)\r\nCREATE OR REPLACE FUNCTION schedule_rate_limit_cleanup()\r\nRETURNS VOID AS $$\r\nBEGIN\r\n  PERFORM cleanup_expired_rate_limits();\r\nEND;\r\n$$ LANGUAGE plpgsql SECURITY DEFINER;\r\n",
      "size": 6034
    },
    {
      "filename": "20250908235000_add_data_jsonb_to_folders_profiles.sql",
      "timestamp": "20250908235000",
      "name": "add data jsonb to folders profiles",
      "path": "supabase\\migrations\\20250908235000_add_data_jsonb_to_folders_profiles.sql",
      "content": "-- Migration: Add data JSONB columns to folders and profiles\r\nALTER TABLE public.folders ADD COLUMN IF NOT EXISTS data JSONB DEFAULT '{}'::jsonb;\r\nALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS data JSONB DEFAULT '{}'::jsonb;\r\n",
      "size": 233
    }
  ],
  "issues": [],
  "summary": {
    "totalMigrations": 10,
    "totalSize": 56032,
    "dateRange": {
      "earliest": "20250906000001",
      "latest": "20250908235000"
    },
    "tablesCreated": [
      "profiles",
      "worlds",
      "world_members",
      "folders",
      "templates",
      "entities",
      "relationships",
      "world_bans",
      "world_invites",
      "activity_logs",
      "world_files",
      "rate_limits",
      "rate_limit_configs"
    ],
    "policiesCreated": 84,
    "indexesCreated": 31,
    "functionsCreated": 11
  }
}